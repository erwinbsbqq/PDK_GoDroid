/*****************************************************************************
*    Copyright (c) 2013 ALi Corp. All Rights Reserved
*    This source is confidential and is ALi's proprietary information.
*    This source is subject to ALi License Agreement, and shall not be 
     disclosed to unauthorized individual.    
*    File: ali_hw_sha.c
*   
*    Description: 
*       simple driver for SHA module, only support SHA256 now
*    THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
     KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
     PARTICULAR PURPOSE.
*****************************************************************************/
#include "ali_simple_dsc.h"
#include "lib_rsa.h"

#define osal_task_sleep(ms)  mdelay(ms)
#define osal_delay(us)  udelay(us)

static UINT32 g_base_addr = 0;
static void dsc_init()
{
    g_base_addr = 0x18034000;
}


//for non AS project which have not the dual os 
static void sha_start(UINT32 *src, UINT32 *tgt, UINT32 len)
{
    UINT32 stat,i;
    DSC_WRITE_WORD(g_base_addr+0x304,(0x1));//clear sha status
    DSC_WRITE_WORD(g_base_addr+0x94,(0x13));//clear dma event
    DSC_WRITE_WORD(g_base_addr+0x300,(1<<30)); //set sha    
    DSC_WRITE_WORD(g_base_addr+0x318,(3<<4));  
    DSC_WRITE_WORD(g_base_addr+0x80,((UINT32)src&0xfffffff));    
    DSC_WRITE_WORD(g_base_addr+0x88,((UINT32)len));    
    //start DMA
    DSC_WRITE_WORD(g_base_addr+0x90,((0x5<<16)|(0x47))); 
    do
    {
        osal_task_sleep(1);
        stat = DSC_READ_WORD(g_base_addr+0x304)&(0x1);    
    }while(!stat);
    DSC_WRITE_WORD(g_base_addr+0x94,(0x13));//clear dma event
    DSC_WRITE_WORD(g_base_addr+0x304,(0x1));//clear sha status
    for(i=0;i<8;i++)
    {
        DSC_WRITE_WORD(g_base_addr+0x318,(3<<4)|i);
        *(tgt+i)=DSC_READ_WORD(g_base_addr+0x314);    
    }
}

RET_CODE check_align(UINT32 input)
{
    if(input&0x2 != 0)
    {
        printf("Give SHA IP data addr is not 4 bytes align\n");
        return RET_FAILURE;
    }
    return RET_SUCCESS;
}
/*
UINT32 *input: the address of the input data 
UINT32 length: the length of input data
UINT32 *output: digest of input data
*/
RET_CODE create_sha_ramdrv(UINT8 *input, UINT32 length, UINT32 *output)
{
    RET_CODE ret;
    
    dsc_init();
    //osal_cache_flush((UINT32)input,length);
    //osal_task_dispatch_off();
    // Current, Uboot only use opne interrupt on RPC Driver.
    //osal_interrupt_disable();
    //check input addr 4 bytes align
    ret = check_align((UINT32)input);
    if(ret != RET_SUCCESS)
        return ret;
    sha_start(input,(output),length);
    //osal_interrupt_enable();
    //osal_task_dispatch_on();        
    return RET_SUCCESS;
}

#if 0

/*
type: reserved
key:  key data,only for key from register
*/
static void aes_fill_key(UINT32 *key, UINT32 *iv, UINT32 type)
{
    //set iv value for AES, Iv from register   
    DSC_WRITE_WORD(g_base_addr+0x230,BYTESWAP(iv[0]));
    DSC_WRITE_WORD(g_base_addr+0x234,BYTESWAP(iv[1]));
    DSC_WRITE_WORD(g_base_addr+0x238,BYTESWAP(iv[2]));
    DSC_WRITE_WORD(g_base_addr+0x23c,BYTESWAP(iv[3]));  
    DSC_WRITE_WORD(g_base_addr+0x27c,BYTESWAP(key[3]));//AES key odd7 key[31:0]
    DSC_WRITE_WORD(g_base_addr+0x278,BYTESWAP(key[2]));//AES key odd6 key[63;32]
    DSC_WRITE_WORD(g_base_addr+0x274,BYTESWAP(key[1]));//AES key odd6 key[95:64]
    DSC_WRITE_WORD(g_base_addr+0x270,BYTESWAP(key[0]));//AES key odd6 key[127:96	
    DSC_WRITE_WORD(g_base_addr+0x0,(0x101));//set key mode 0x101        
}
/*
type: DSC_ENCRYPT = 0, DSC_DECRYPT = 1   
crypto_mode: 0: CBC mode; 1: ECB mode
*/
static int aes_start(UINT32 *src, UINT32 *tgt, UINT32 len,UINT32 type, UINT32 crypto_mode)
{
    UINT32 stat;
    UINT32 timeout = 100000;
    //dma_cache_wback_inv((UINT8 *)src, len);	
    osal_cache_flush((UINT8 *)src, len);
    DSC_WRITE_WORD(g_base_addr+0x94,(0x13));//clear dma event
    DSC_WRITE_WORD(g_base_addr+0x200,(0x06|(type<<8)|(crypto_mode<<4)));//0x106: AES decrypt mode   0x06: AES encrypt mode     
    DSC_WRITE_WORD(g_base_addr+0x80,((UINT32)src)&(0xfffffff));  
    DSC_WRITE_WORD(g_base_addr+0x84,((UINT32)tgt)&(0xfffffff));    
    //DSC_WRITE_WORD(g_base_addr+0x0,(0x103));//set key mode 0x100 key from sram, 0x103 key from OTP    
    DSC_WRITE_WORD(g_base_addr+0x90,((0x1<<17)|(0x47))); 
    //Need config the mode first, then config the length.
    DSC_WRITE_WORD(g_base_addr+0x88,((UINT32)len));    
    //start DMA
    DSC_WRITE_WORD(g_base_addr+0x90,((0x3<<16)|(0x47))); 
    do
    {
        timeout--;
        stat = DSC_READ_WORD(g_base_addr+0x94)&(0x1<<8);    
    }while((stat)&&(0!=timeout));
    if(0==timeout)
        return -1;
    DSC_WRITE_WORD(g_base_addr+0x94,(0x13));//clear dma event
    //dma_cache_inv((UINT8 *)tgt, len);
    osal_cache_invalidate((UINT8 *)tgt, len);
    return 0;
}




/*
UINT32 *key: 128 bit key point
UINT32 *src: the address of input data, the buffer for the input need to be consecutive and 4 bytes align
UINT32 *tgt: the address of output data, the buffer for the output need to be consecutive and 4 bytes align
UINT32 len:  the data length of the crypt data
UINT32 type: the crypto mode, 0 means encrypt, 1 means decrypt.
UINT32 crypto_mode: the residue data mode, 0 means CBC mode, 1 means ECB mode
*/
int ali_aes_crypt_simple(UINT32 *key, UINT32 *iv, UINT32 *src, UINT32 *tgt, UINT32 len, UINT32 type,UINT32 crypto_mode)
{
	int ret=-1;	
       dsc_init();
	aes_fill_key(key, iv, 0);
	ret = aes_start(src, tgt, len, type, crypto_mode);
	return ret;
}


void ali_test_simple()
{	
    UINT32 i=0;
    int ret=-1;	
    UINT8 input[256]={0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xce,0xe2,0x02,0x6a,
                        0x91,0x44,0x21,0xd7,0x2b,0x57,0xc7,0x9a,0xaf,0xbb,0xe4,0x14,0xf9,0xcf,0x2e,0xb1,
                        0xbe,0x66,0x72,0x6a,0x1a,0x6b,0x84,0x38,0x0e,0x34,0x33,0x92,0x8d,0x88,0x7c,0x05,
                        0xcb,0x1d,0x2d,0x22,0x2c,0xed,0x1b,0x8e,0xee,0x5d,0x6c,0xda,0x9c,0x56,0xc7,0x31,
                        0x92,0x18,0xc0,0x29,0x0f,0x1b,0xb7,0xa3,0x37,0x71,0x5d,0x25,0xbc,0xf8,0xac,0xcb,
                        0x01,0x3c,0x36,0x6b,0x14,0x73,0xe6,0x65,0xd5,0xc4,0x24,0x1f,0x5d,0xde,0x48,0xc2,
                        0xae,0x91,0x63,0x98,0x54,0x94,0x1f,0x5c,0x09,0xfa,0x7f,0xef,0x06,0xe1,0xc6,0x0f,
                        0xc2,0xb2,0x46,0x63,0xde,0x2f,0x94,0xc2,0x14,0xdd,0x85,0x52,0xc5,0x27,0xe0,0x2c,
                        0xfc,0xd3,0x86,0x8d,0x67,0x2e,0x5d,0x2a,0x16,0x7e,0xeb,0xfe,0x34,0x8c,0x03,0x11,
                        0x59,0x4c,0xbb,0x38,0x17,0x19,0x56,0xab,0x6e,0x9a,0x46,0x2d,0xad,0x92,0x86,0x4c,
                        0x55,0xdb,0x65,0xca,0xaa,0x40,0x17,0xad,0xee,0xa4,0x37,0xe4,0xa7,0x95,0x4d,0x6c,
                        0x7d,0xa4,0x3b,0x8f,0x39,0xff,0x19,0x97,0x51,0xdd,0x0d,0xf4,0xf7,0x96,0x18,0x90,
                        0x41,0x2c,0x4e,0xa6,0x3f,0xa1,0x1b,0x22,0x83,0x62,0x91,0xd4,0xef,0x6b,0x67,0xef,
                        0x29,0xa8,0x9a,0xeb,0x5d,0x5f,0xf9,0xbc,0x64,0xba,0x7c,0x11,0x82,0x40,0x82,0xd5,
                        0xd3,0x44,0xf5,0xa1,0x7b,0x1b,0xe2,0x41,0x26,0xda,0x33,0x24,0x56,0x01,0xbe,0xad,
                        0xac,0x1c,0xa9,0xab,0x89,0x8e,0x7a,0x92,0xc3,0x50,0xdb,0x2b,0x26,0x96,0x1b,0xad,
                      }; 
    UINT8 output[256];
    /*UINT8 output_standard_CBC[256]=
    {
        0x40,0xee,0xf9,0xa9,0xe2,0xb4,0x20,0xc9,0x53,0x36,0xf8,0x79,0x13,0x2e,0xb9,0xc4,
        0x0e,0x7d,0xf9,0xb4,0x21,0x18,0x3f,0x41,0xb2,0x91,0xaf,0x93,0xeb,0x56,0x8d,0x87,
        0xbf,0x54,0xf7,0x7c,0x5e,0xfe,0xe8,0x84,0x15,0x86,0xd1,0xd2,0x97,0xdb,0xb3,0x53,
        0xea,0xc2,0x6e,0x16,0x5f,0xd6,0xc2,0x58,0x9d,0x2f,0xc3,0x82,0xb1,0xd1,0x4b,0x95,
        0xeb,0xe2,0x71,0xaa,0x93,0xbd,0xc8,0x5a,0xae,0x55,0x0f,0x62,0x10,0x90,0x84,0xbd,
        0x1e,0x8d,0x70,0x08,0x1c,0x95,0x81,0x47,0x1b,0xed,0x28,0xa0,0x32,0x9c,0xa9,0x29,
        0xbd,0x54,0xdc,0x27,0xe6,0xab,0x90,0xd5,0xfc,0xe1,0x34,0x93,0x85,0xff,0xcc,0xd3,
        0x2a,0x28,0x00,0x13,0x65,0xbd,0x06,0x2b,0x71,0xa7,0x33,0xab,0xe2,0x36,0xf3,0xac,
        0xcd,0xf7,0x6a,0x66,0x8f,0x2e,0xce,0xf9,0xf5,0x21,0x65,0xe1,0x74,0x5f,0xb4,0xe6,
        0x13,0xcf,0x80,0xc4,0x5b,0x8a,0xa2,0x99,0x83,0x8e,0xb7,0xe5,0xed,0xa0,0x61,0x8a,
        0xac,0xab,0x1a,0x6b,0x53,0x59,0x74,0x6f,0x3f,0x2a,0x35,0xb4,0xea,0x18,0x60,0x62,
        0xf4,0x7a,0x70,0x12,0x92,0x18,0xb4,0x81,0xbd,0x0c,0xf0,0xa6,0x7c,0xb3,0x4f,0x8d,
        0x55,0x44,0x8b,0x02,0x5c,0x0e,0x92,0x2f,0x59,0x9b,0x66,0xfb,0x9c,0x4c,0x02,0x3a,
        0x32,0x67,0x8e,0xe4,0xab,0xda,0x2a,0xa5,0x7c,0x03,0x08,0x33,0x86,0x33,0xe2,0x9e,
        0x5d,0x82,0x36,0x9b,0x17,0x5f,0x84,0x5f,0xcd,0xd9,0x6a,0x6d,0xca,0xfe,0xeb,0x58,
        0x21,0x15,0x83,0x23,0x03,0x50,0xcc,0x3b,0xc8,0x6f,0xd4,0x83,0xc1,0x7c,0x94,0xe2,
    };
    UINT8 output_standard_ECB[256]=
    {
        0xc8,0x18,0x15,0xcb,0x92,0xf9,0xcc,0x47,0xff,0xea,0xeb,0x48,0x9c,0x6a,0xa8,0x40,
        0x3e,0x7b,0x18,0x9e,0x95,0x3e,0x8f,0x37,0x2e,0x62,0x05,0x3a,0xd4,0x49,0xb1,0x1e,
        0x62,0x86,0xb7,0xad,0xd9,0x41,0x99,0x51,0xd9,0x25,0xa9,0xdb,0xc1,0xe2,0xfd,0x2a,
        0xbd,0xe4,0xd1,0x48,0x83,0x80,0x0b,0x92,0x40,0x88,0xed,0x69,0x8a,0x44,0x1e,0xdc,
        0xbf,0xaf,0x09,0x3e,0x01,0x90,0xa0,0x63,0xd6,0x88,0xb6,0x39,0x16,0x98,0x95,0xd0,
        0x78,0xe6,0xcd,0x86,0xf5,0xb4,0x60,0x26,0xba,0x48,0x3d,0x39,0xc1,0x29,0x7c,0xbb,
        0xcf,0x53,0x4e,0x12,0x5c,0x7c,0xf3,0x2b,0xa5,0x29,0x40,0x59,0x5e,0x1d,0xc2,0x08,
        0xf8,0xd9,0xc2,0xe3,0x96,0x98,0x61,0x27,0x11,0xe1,0x0f,0xce,0x50,0x39,0x98,0x1e,
        0xe2,0xa8,0xef,0x05,0x80,0x0a,0xa2,0x66,0x71,0x97,0x6b,0xa6,0x4b,0xc6,0x31,0xfd,
        0x4c,0x19,0xad,0xec,0xd3,0x02,0x06,0xdb,0xf5,0xa0,0x6b,0x5f,0xdd,0xc2,0x0b,0x42,
        0x8f,0x6d,0xa2,0x43,0x8e,0x42,0x8d,0x35,0x51,0x42,0x19,0xf8,0x5e,0x95,0x57,0x1f,
        0xa2,0x81,0x13,0xb1,0x1c,0xc8,0x0b,0xb8,0xc1,0xf4,0xb5,0x65,0xa2,0xb4,0x2b,0x7b,
        0xca,0x35,0x86,0x5e,0xcf,0xb8,0x30,0x1f,0xec,0x20,0x7d,0xc9,0xa7,0x59,0xd8,0xf3,
        0xaf,0x53,0x08,0x7b,0xda,0xd9,0x98,0xe5,0x58,0x81,0x17,0xb8,0xb3,0x1a,0x6b,0x4e,
        0x2b,0x18,0xd8,0x1c,0x2e,0x9f,0xbc,0x75,0xc1,0x48,0xeb,0x66,0x79,0xf1,0xbc,0x3f,
        0xe1,0x3d,0x15,0x1d,0xc2,0x7d,0x3b,0x1d,0x48,0xfc,0x98,0x76,0xf7,0xc0,0x98,0x39,
    };
    UINT8 output_standard_SHA[32]={0xE8F013DC2E56D2479C2DBAE220C56F339E8315E160AE1A1AE8DBAFEB94EFDEA8};*/
    
    UINT8 iv[16]={0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,
                    0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88};
    UINT8 key[16]={0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
                    0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22
                    };  
    memset(output, 0, 256);
    //CBC test
    ret = ali_aes_crypt_simple(key, iv, input, output,256,0,0);    
    //compare the output with output_standard_CBC
    //ECB test
    memset(output, 0, 256);
    ret = ali_aes_crypt_simple(key, iv, input, output,256,0,1); 
    //compare the output with output_standard_ECB
    //SHA test
    memset(output, 0, 256);
    ret = create_sha_ramdrv(input, 256, output); 
    //compare the output with output_standard_SHA
    
}
#endif