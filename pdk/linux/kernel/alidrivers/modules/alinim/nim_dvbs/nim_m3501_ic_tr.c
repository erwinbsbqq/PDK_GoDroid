/*****************************************************************************
*    Copyright (c) 2013 ALi Corp. All Rights Reserved
*    This source is confidential and is ALi's proprietary information.
*    This source is subject to ALi License Agreement, and shall not be
     disclosed to unauthorized individual.
*    File:  nim_m3501_ic_01.c
*
*    Description:  m3501 ic layer
*    THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
      KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
      PARTICULAR PURPOSE.
*****************************************************************************/

#include "nim_m3501.h"

INT32  s3501_snr_initial_en = 0; // Seen, 1 means first snr estimation done, set 1 in channel change

#define TDATA_SUM           4

#define FREQ_P_V            5750
#define FREQ_P_H            5150
#define KU_C_BAND_INTERFACE 8000
#define INTERVAL_CNT_16     16
#define TAB_ID_2            2
#define CNT_NUM_3           3
#define CUR_MAX_ITER_50     50
#define CUR_MAX_ITER_35     35
#define CR_IRS_VAL_6        6
#define CR_PRS_VAL_4        4
#define INTERVAL_CNT_10     10
#define CLK_SEL_6           6
#define SUM_VALUE_255       255

#ifdef NIM_S3501_ASCAN_TOOLS

struct nim_s3501_ascan vs_s3501_ascan =
{
    0,
    0,
    0,
    1,
    {0, 0, 0, 0, 0}, // equals VD_OSD_RPT_CNT ,5
    0,
    {0, 0, 0, 0, 0}, // equals VD_OSD_RPT_CNT ,5
    1,
    {0, 0, 0, 0, 0}, // equals VD_OSD_RPT_CNT ,5
    {0, 0, 0, 0, 0}, // equals VD_OSD_RPT_CNT ,5
    900,
    2200,
    0,
    1,
    0,
};
struct nim_s3501_tp va_g2_ascan_tps[VD_REF_SATELLATE_CNT][VD_TP_CNT] =
{
#if 0
    //polarize: 0->H  1->V
    {
        {4171, FREQ_P_H - 4171,    9200,   0, 0}, //979
        {4158, FREQ_P_H - 4158,    8680,   0, 0}, //992
        {4147, FREQ_P_H - 4147,    6150,   0, 0}, //1003
        {4115, FREQ_P_H - 4115,    21375,  0, 0}, //1035
        {4080, FREQ_P_H - 4080,    27500,  0, 0}, //1070
        {4040, FREQ_P_H - 4040,    27500,  0, 0}, //1110
        {4000, FREQ_P_H - 4000,    27500,  0, 0}, //1150
        {3972, FREQ_P_H - 3972,    10000,  0, 0}, //1178
        {3960, FREQ_P_H - 3960,    3570,   0, 0}, //1190
        {3950, FREQ_P_H - 3950,    11400,  0, 0}, //1200
        {3920, FREQ_P_H - 3920,    27500,  0, 0}, //1230
        {3880, FREQ_P_H - 3880,    27500,  0, 0}, //1270
        {3840, FREQ_P_H - 3840,    27500,  0, 0}, //1310
        {3818, FREQ_P_H - 3818,    3160,   0, 0}, //1332
        {3808, FREQ_P_H - 3808,    8800,   0, 0}, //1342
        {3796, FREQ_P_H - 3796,    6930,   0, 0}, //1354
        {3786, FREQ_P_H - 3786,    5440,   0, 0}, //1364
        {3769, FREQ_P_H - 3769,    13400,  0, 0}, //1381
        {3750, FREQ_P_H - 3750,    10490,  0, 0}, //1400
        {3730, FREQ_P_H - 3730,    10720,  0, 0}, //1420
        {3706, FREQ_P_H - 3706,    4420,   0, 0}, //1444
        //      {3555,FREQ_P_H-3555,    1800,   0,0},//1595

        {4192, FREQ_P_V - 4192,    6000,   1, 0}, //1558
        {4175, FREQ_P_V - 4175,    18000,  1, 0}, //1575
        {4140, FREQ_P_V - 4140,    27500,  1, 0}, //1610
        {4100, FREQ_P_V - 4100,    27500,  1, 0}, //1650
        {4060, FREQ_P_V - 4060,    27500,  1, 0}, //1690
        {4020, FREQ_P_V - 4020,    27500,  1, 0}, //1730
        {3980, FREQ_P_V - 3980,    27500,  1, 0}, //1770
        {3951, FREQ_P_V - 3951,    9520,   1, 0}, //1799
        {3940, FREQ_P_V - 3940,    5950,   1, 0}, //1810
        {3929, FREQ_P_V - 3929,    8840,   1, 0}, //1821
        {3913, FREQ_P_V - 3913,    6400,   1, 0}, //1837
        {3902, FREQ_P_V - 3902,    9300,   1, 0}, //1848
        {3892, FREQ_P_V - 3892,    4420,   1, 0}, //1858
        {3885, FREQ_P_V - 3885,    4340,   1, 0}, //1865
        {3871, FREQ_P_V - 3871,    9080,   1, 0}, //1879
        {3861, FREQ_P_V - 3861,    4800,   1, 0}, //1889
        {3854, FREQ_P_V - 3854,    4420,   1, 0}, //1896
        {3846, FREQ_P_V - 3846,    5950,   1, 0}, //1904
        {3834, FREQ_P_V - 3834,    5400,   1, 0}, //1916
        {3825, FREQ_P_V - 3825,    6780,   1, 0}, //1925
        {3807, FREQ_P_V - 3807,    6000,   1, 0}, //1943
        {3780, FREQ_P_V - 3780,    27500,  1, 0}, //1970
        {3740, FREQ_P_V - 3740,    27500,  1, 0}, //2010
        {3680, FREQ_P_V - 3680,    27500,  1, 0}, //2070
        {3640, FREQ_P_V - 3640,    27500,  1, 0}, //2110
        {3600, FREQ_P_V - 3600,    27500,  1, 0}, //2150
    },
    //亚太V号
    {
        //H
        {12282, 12282 - 10600, 16300,  0, 0}, //1682
        {12316, 12316 - 10600, 1500,  0, 0}, //1716
        {12320, 12320 - 10600, 5000,  0, 0}, //1720
        {12334, 12334 - 10600, 7666, 0, 0}, //1734
        {12362, 12362 - 10600, 2220, 0, 0}, //1762
        {12380, 12380 - 10600, 2400,    0, 0}, //1780
        {12401, 12401 - 10600, 17575,   0, 0}, //1801
        {12429, 12429 - 10600, 3330, 0, 0}, //1829
        {12442, 12442 - 10600, 1537, 0, 0}, //1842
        {12630, 12630 - 10600, 43200,   0, 0}, //2030
        {12690, 12690 - 10600, 43200,   0, 0}, //2090
        //V
        {12275, 12275 - 10600, 15000, 1, 0}, //1675
        {12302, 12302 - 10600, 30000,   1, 0}, //1702
        {12354, 12354 - 10600, 43000,   1, 0}, //1754
        {12401, 12401 - 10600, 22425,   1, 0}, //1801
        {12430, 12430 - 10600, 22425,   1, 0}, //1830
        {12472, 12472 - 10600, 33500,   1, 0}, //1872
        {12537, 12537 - 10600, 41248,   1, 0}, //1937
        {12598, 12598 - 10600, 43000,   1, 0}, //1998
        {12646, 12646 - 10600, 22425,   1, 0}, //2046
        {12663, 12663 - 10600, 4285,    1, 0}, //2063
        {12669, 12669 - 10600, 4285,    1, 0}, //2069
        {12675, 12675 - 10600, 4285,    1, 0}, //2075
        {12685, 12685 - 10600, 3000,    1, 0}, //2085
        {12721, 12721 - 10600, 43000,   1, 0}, //2121
    },
    //新天6号
    {
        {11640, 11640 - 9750, 27500,  0, 0}, //1890
        {11676, 11676 - 9750, 27500,  0, 0}, //1926
        {12647, 12647 - 10750, 28000, 0, 0}, //1897
        {12686, 12686 - 10750, 28000, 0, 0}, //1936
        {12690, 12690 - 10750, 43200,  0, 0}, //1940
        {12728, 12728 - 10750, 26400,   0, 0}, //1978
        //
        {11130, 11130 - 9750, 30000,    1, 0}, //1380
        {11170, 11170 - 9750, 30000,    1, 0}, //1420
        {11540, 11540 - 9750, 43200,    1, 0}, //1790
        {11675, 11675 - 9750, 28800,    1, 0}, //1925
    },
    //马星3号
    {
        {4163, 5150 - 4163, 14400, 0, 0}, //987
        {4148, 5150 - 4148, 7200, 0, 0}, //1002
        {4120, 5150 - 4120, 30000, 0, 0}, //1030
        {4040, 5150 - 4040, 28600, 0, 0}, //1110
        {4000, 5150 - 4000, 30000, 0, 0}, //1150
        {3736, 5150 - 3736, 3000, 0, 0}, //1414
        {3710, 5150 - 3710, 2856, 0, 0}, //1440
        {3705, 5150 - 3705, 4290, 0, 0}, //1445

        {4120, 5150 - 4120, 29720, 1, 0}, //1030
        {4084, 5150 - 4084, 10000, 1, 0}, //1066
        {4035, 5150 - 4035, 3300, 1, 0}, //1115
        {4000, 5150 - 4000, 5000, 1, 0}, //1150
        {3920, 5150 - 3920, 29720, 1, 0}, //1230
        {3896, 5150 - 3896, 39000, 1, 0}, //1254
        {3887, 5150 - 3887, 3984, 1, 0}, //1263
        {3876, 5150 - 3876, 18385, 1, 0}, //1274
        {3864, 5150 - 3864, 2917, 1, 0}, //1286
        {3840, 5150 - 3840, 29720, 1, 0}, //1310
        {3814, 5150 - 3814, 6666, 1, 0}, //1336
        {3806, 5150 - 3806, 3255, 1, 0}, //1344
        {3794, 5150 - 3794, 5063, 1, 0}, //1356
        {3760, 5150 - 3760, 29720, 1, 0}, //1390
        {3721, 5150 - 3721, 2170, 1, 0}, //1429
        {3641, 5150 - 3641, 13333, 1, 0}, //1509
        {3616, FREQ_P_V - 3616, 3213, 1, 0}, //1534
    },
    //越星1号
    {
        {10968, 10968 - 9750, 28800, 0, 0}, //1218
        {11008, 11008 - 9750, 28800, 0, 0}, //1258
        {11048, 11048 - 9750, 28800, 0, 0}, //1298
        {11087, 11087 - 9750, 28125, 0, 0}, //1337
        {11121, 11121 - 9750, 13333, 0, 0}, //1371
        {11135, 11135 - 9750, 9600, 0, 0}, //1385
        {11472, 11472 - 9750, 23200, 0, 0}, //1722
        {11517, 11517 - 9750, 4700, 0, 0}, //1767
        {11531, 11531 - 9750, 2500, 0, 0}, //1781
        {11549, 11549 - 9750, 28490, 0, 0}, //1799
        {11590, 11590 - 9750, 28800, 0, 0}, //1840
        {11629, 11629 - 9750, 28800, 0, 0}, //1879
        {11669, 11669 - 9750, 30000, 0, 0}, //1919
    },
    //亚太2R
    {
        //H
        {4175, 5150 - 4175, 4285, 0, 0}, //975
        {4169, 5150 - 4169, 4285, 0, 0}, //981
        {4163, 5150 - 4163, 4340, 0, 0}, //987
        {4145, 5150 - 4145, 3600, 0, 0}, //1005
        {4133, 5150 - 4133, 3750, 0, 0}, //1017
        {4119, 5150 - 4119, 4444, 0, 0}, //1031
        {4113, 5150 - 4113, 3695, 0, 0}, //1037
        {4109, 5150 - 4109, 2000, 0, 0}, //1041
        {4105, 5150 - 4105, 3125, 0, 0}, //1045
        {4085, 5150 - 4085, 2530, 0, 0}, //1065
        {4070, 5150 - 4070, 13020, 0, 0}, //1080
        {4056, 5150 - 4056, 3212, 0, 0}, //1094
        {4049, 5150 - 4049, 4290, 0, 0}, //1101
        {4034, 5150 - 4034, 4300, 0, 0}, //1116
        {4016, 5150 - 4016, 4340, 0, 0}, //1134
        {4009, 5150 - 4009, 4290, 0, 0}, //1141
        {4004, 5150 - 4004, 4324, 0, 0}, //1146
        {3997, 5150 - 3997, 3190, 0, 0}, //1153
        {3985, 5150 - 3985, 3700, 0, 0}, //1165
        {3960, 5150 - 3960, 30000, 0, 0}, //1190
        {3920, 5150 - 3920, 28340, 0, 0}, //1230
        {3880, 5150 - 3880, 28125, 0, 0}, //1270
        {3840, 5150 - 3840, 27500, 0, 0}, //1310
        {3815, 5150 - 3815, 3333, 0, 0}, //1335
        {3811, 5150 - 3811, 3980, 0, 0}, //1339
        {3805, 5150 - 3805, 4340, 0, 0}, //1345
        {3799, 5150 - 3799, 4330, 0, 0}, //1351
        {3793, 5150 - 3793, 4444, 0, 0}, //1357
        {3787, 5150 - 3787, 4600, 0, 0}, //1363
        {3720, 5150 - 3720, 29620, 0, 0}, //1430
        {3680, 5150 - 3680, 27500, 0, 0}, //1470
        {3655, 5150 - 3655, 3214, 0, 0}, //1495
        {3648, 5150 - 3648, 6500, 0, 0}, //1502
        {3629, 5150 - 3629, 1489, 0, 0}, //1521
        //V
        {4030, 5150 - 4030, 6312, 1, 0}, //1120
        {3993, 5150 - 3993, 1482, 1, 0}, //1157
        {3956, 5150 - 3956, 2340, 1, 0}, //1194
        {3814, 5150 - 3814, 6666, 1, 0}, //1336
        {3755, 5150 - 3755, 4640, 1, 0}, //1395
        {3747, 5150 - 3747, 8000, 1, 0}, //1403
        {3705, 5150 - 3705, 8888, 1, 0}, //1445
    },
    //亚洲3S
    {
        {4177, 5150 - 4177,    2444,   0, 0}, //973
        {4172, 5150 - 4172,    2480,   0, 0}, //978
        {4165, 5150 - 4165,    5710,   0, 0}, //985
        {4160, 5150 - 4160,    3030,   0, 0}, //990
        {4154, 5150 - 4154,    5632,   0, 0}, //996
        {4146, 5150 - 4146,    3784,   0, 0}, //1004
        {4132, 5150 - 4132,    9200,   0, 0}, //1018
        {4125, 5150 - 4125,    2444,   0, 0}, //1025
        {4097, 5150 - 4097,    2256,   0, 0}, //1053
        {4071, 5150 - 4071,    14240,  0, 0}, //1079
        {4040, 5150 - 4040,    26500,  0, 0}, //1110
        {4000, 5150 - 4000,    26850,  0, 0}, //1150
        {3960, 5150 - 3960,    27500,  0, 0}, //1190
        {3920, 5150 - 3920,    26666,  0, 0}, //1230
        {3880, 5150 - 3880,    27500,  0, 0}, //1270
        {3840, 5150 - 3840,    26850,  0, 0}, //1310
        {3760, 5150 - 3760,    26000,  0, 0}, //1390
        {3729, 5150 - 3729,    13650,  0, 0}, //1421
        {3706, 5150 - 3706,    6000,   0, 0}, //1444
        {4180, 5150 - 4180,    26666,  1, 0}, //970
        {4140, 5150 - 4140,    27500,  1, 0}, //1010
        {4114, 5150 - 4114,    7000,   1, 0}, //1036
        {4107, 5150 - 4107,    2893,   1, 0}, //1043
        {4102, 5150 - 4102,    2893,   1, 0}, //1048
        {4091, 5150 - 4091,    13333,  1, 0}, //1059
        {4060, 5150 - 4060,    26667,  1, 0}, //1090
        {4020, 5150 - 4020,    27250,  1, 0}, //1130
        {3980, 5150 - 3980,    28100,  1, 0}, //1170
        {3940, 5150 - 3940,    28100,  1, 0}, //1210
        {3914, 5150 - 3914,    7230,   1, 0}, //1236
        {3906, 5150 - 3906,    2813,   1, 0}, //1244
        {3888, 5150 - 3888,    9220,   1, 0}, //1262
        {3860, 5150 - 3860,    27500,  1, 0}, //1290
        {3820, 5150 - 3820,    27500,  1, 0}, //1330
        {3780, 5150 - 3780,    28100,  1, 0}, //1395
        {3755, 5150 - 3755,    4418,   1, 0}, //1395
        {3750, 5150 - 3750,    3030,   1, 0}, //1400
        {3745, 5150 - 3745,    2626,   1, 0}, //1405
        {3739, 5150 - 3739,    2816,   1, 0}, //1411
        {3732, 5150 - 3732,    6500,   1, 0}, //1418
        {3711, 5150 - 3711,    11400,  1, 0}, //1439
        {3665, 5150 - 3665,    7500,   1, 0}, //1485
    },
#else
    //polarize: 0->H  1->V
    {
        {FREQ_P_H, 4171, FREQ_P_H - 4171,   9200,   0, 0}, //979
        {FREQ_P_H, 4158, FREQ_P_H - 4158,   8680,   0, 0}, //992
        {FREQ_P_H, 4147, FREQ_P_H - 4147,   6150,   0, 0}, //1003
        {FREQ_P_H, 4115, FREQ_P_H - 4115,   21375,  0, 0}, //1035
        {FREQ_P_H, 4080, FREQ_P_H - 4080,   27500,  0, 0}, //1070
        {FREQ_P_H, 4040, FREQ_P_H - 4040,   27500,  0, 0}, //1110
        {FREQ_P_H, 4000, FREQ_P_H - 4000,   27500,  0, 0}, //1150
        {FREQ_P_H, 3972, FREQ_P_H - 3972,   10000,  0, 0}, //1178
        {FREQ_P_H, 3960, FREQ_P_H - 3960,   3570,   0, 0}, //1190
        {FREQ_P_H, 3950, FREQ_P_H - 3950,   11400,  0, 0}, //1200
        {FREQ_P_H, 3920, FREQ_P_H - 3920,   27500,  0, 0}, //1230
        {FREQ_P_H, 3880, FREQ_P_H - 3880,   27500,  0, 0}, //1270
        {FREQ_P_H, 3840, FREQ_P_H - 3840,   27500,  0, 0}, //1310
        {FREQ_P_H, 3818, FREQ_P_H - 3818,   3160,   0, 0}, //1332
        {FREQ_P_H, 3808, FREQ_P_H - 3808,   8800,   0, 0}, //1342
        {FREQ_P_H, 3796, FREQ_P_H - 3796,   6930,   0, 0}, //1354
        {FREQ_P_H, 3786, FREQ_P_H - 3786,   5440,   0, 0}, //1364
        {FREQ_P_H, 3769, FREQ_P_H - 3769,   13400,  0, 0}, //1381
        {FREQ_P_H, 3750, FREQ_P_H - 3750,   10490,  0, 0}, //1400
        {FREQ_P_H, 3730, FREQ_P_H - 3730,   10720,  0, 0}, //1420
        {FREQ_P_H, 3706, FREQ_P_H - 3706,   4420,   0, 0}, //1444
        //      {3555,FREQ_P_H-3555,    1800,   0,0},//1595
        {FREQ_P_V, 4192, FREQ_P_V - 4192,   6000,   1, 0}, //1558
        {FREQ_P_V, 4175, FREQ_P_V - 4175,   18000,  1, 0}, //1575
        {FREQ_P_V, 4140, FREQ_P_V - 4140,   27500,  1, 0}, //1610
        {FREQ_P_V, 4100, FREQ_P_V - 4100,   27500,  1, 0}, //1650
        {FREQ_P_V, 4060, FREQ_P_V - 4060,   27500,  1, 0}, //1690
        {FREQ_P_V, 4020, FREQ_P_V - 4020,   27500,  1, 0}, //1730
        {FREQ_P_V, 3980, FREQ_P_V - 3980,   27500,  1, 0}, //1770
        {FREQ_P_V, 3951, FREQ_P_V - 3951,   9520,   1, 0}, //1799
        {FREQ_P_V, 3940, FREQ_P_V - 3940,   5950,   1, 0}, //1810
        {FREQ_P_V, 3929, FREQ_P_V - 3929,   8840,   1, 0}, //1821
        {FREQ_P_V, 3913, FREQ_P_V - 3913,   6400,   1, 0}, //1837
        {FREQ_P_V, 3902, FREQ_P_V - 3902,   9300,   1, 0}, //1848
        {FREQ_P_V, 3892, FREQ_P_V - 3892,   4420,   1, 0}, //1858
        {FREQ_P_V, 3885, FREQ_P_V - 3885,   4340,   1, 0}, //1865
        {FREQ_P_V, 3871, FREQ_P_V - 3871,   9080,   1, 0}, //1879
        {FREQ_P_V, 3861, FREQ_P_V - 3861,   4800,   1, 0}, //1889
        {FREQ_P_V, 3854, FREQ_P_V - 3854,   4420,   1, 0}, //1896
        {FREQ_P_V, 3846, FREQ_P_V - 3846,   5950,   1, 0}, //1904
        {FREQ_P_V, 3834, FREQ_P_V - 3834,   5400,   1, 0}, //1916
        {FREQ_P_V, 3825, FREQ_P_V - 3825,   6780,   1, 0}, //1925
        {FREQ_P_V, 3807, FREQ_P_V - 3807,   6000,   1, 0}, //1943
        {FREQ_P_V, 3780, FREQ_P_V - 3780,   27500,  1, 0}, //1970
        {FREQ_P_V, 3740, FREQ_P_V - 3740,   27500,  1, 0}, //2010
        {FREQ_P_V, 3680, FREQ_P_V - 3680,   27500,  1, 0}, //2070
        {FREQ_P_V, 3640, FREQ_P_V - 3640,   27500,  1, 0}, //2110
        {FREQ_P_V, 3600, FREQ_P_V - 3600,   27500,  1, 0}, //2150
    },
    //亚太V号
    {
        //H
        {10600, 12294, 12294 - 10600, 3150, 0, 0}, //1694
        {10600, 12325, 12325 - 10600, 4999,  0, 0}, //1725
        {10600, 12338, 12338 - 10600, 7665,  0, 0}, //1738
        {10600, 12383, 12383 - 10600, 2399,  0, 0}, //1783
        {10600, 12433, 12433 - 10600, 3329,  0, 0}, //1833
        {10600, 12456, 12456 - 10600, 4050,  0, 0}, //1856
        {10600, 12633, 12633 - 10600, 43199, 0, 0}, //2033
        {10600, 12445, 12445 - 10600, 1537,  0, 0}, //1845
        {10600, 12693, 12693 - 10600, 43198, 0, 0}, //2093
        {10600, 12321, 12321 - 10600, 1500,  0, 0}, //1721
        {10600, 12281, 12281 - 10600, 3149, 0, 0}, //1681
        //V
        {10600, 12278, 12278 - 10600, 4999,  1, 0}, //1678
        {10600, 12307, 12307 - 10600, 30000,  1, 0}, //1707
        {10600, 12358, 12358 - 10600, 43000,  1, 0}, //1758
        {10600, 12404, 12404 - 10600, 22430, 1, 0}, //1804
        {10600, 12433, 12433 - 10600, 22430, 1, 0}, //1833
        {10600, 12476, 12476 - 10600, 33500, 1, 0}, //1876
        {10600, 12541, 12541 - 10600, 41250, 1, 0}, //1941
        {10600, 12603, 12603 - 10600, 42999, 1, 0}, //2003
        {10600, 12649, 12649 - 10600, 22419, 1, 0}, //2049
        {10600, 12672, 12672 - 10600, 4284,  1, 0}, //2072
        {10600, 12688, 12688 - 10600, 3000,  1, 0}, //2088
        {10600, 12724, 12724 - 10600, 42997, 1, 0}, //2124
    },
    //新天6号
    {
        {9750, 11640, 11640 - 9750, 27500,  0, 0}, //1890
        {9750, 11681, 11681 - 9750, 27499,  0, 0}, //1931
        {10750, 12659, 12659 - 10750, 28000, 0, 0}, //1909
        {10750, 12700, 12700 - 10750, 28000, 0, 0}, //1950
        {10750, 12741, 12741 - 10750, 26403,  0, 0}, //1991
        //
        {9750, 11135, 11135 - 9750, 30000,   1, 0}, //1385
        {9750, 11177, 11177 - 9750, 30000,   1, 0}, //1427
        {9750, 11480, 11480 - 9750, 3159,    1, 0}, //1730
        {9750, 11546, 11546 - 9750, 43198,   1, 0}, //1796
        {9750, 11681, 11681 - 9750, 28799,   1, 0}, //1931
        {10750, 12659, 12659 - 10750, 28000, 1, 0}, //1909
        {10750, 12699, 12699 - 10750, 28000, 1, 0}, //1949
        {10750, 12741, 12741 - 10750, 26403, 1, 0}, //1991
    },

    //马星3号
    {
        {5150, 4166, 5150 - 4166, 20640, 0, 0}, //984
        {5150, 4122, 5150 - 4122, 30000, 0, 0}, //1028
        {5150, 4042, 5150 - 4042, 28600, 0, 0}, //1108
        {5150, 4002, 5150 - 4002, 30000, 0, 0}, //1148
        {5150, 3736, 5150 - 3736, 3000, 0, 0}, //1414
        {5150, 3732, 5150 - 3732, 3199, 0, 0}, //1418
        {5150, 3712, 5150 - 3712, 2857, 0, 0}, //1438
        {5150, 3707, 5150 - 3707, 4290, 0, 0}, //1443
        //
        {5150, 4122, 5150 - 4122, 29720, 1, 0}, //1028
        {5150, 4085, 5150 - 4085, 10000, 1, 0}, //1065
        {5150, 4057, 5150 - 4057, 2499, 1, 0}, //1093
        {5150, 4044, 5150 - 4044, 2499, 1, 0}, //1106
        {5150, 4004, 5150 - 4004, 5000, 1, 0}, //1146
        {5150, 3922, 5150 - 3922, 29720, 1, 0}, //1228
        {5150, 3892, 5150 - 3892, 2916, 1, 0}, //1258
        {5150, 3879, 5150 - 3879, 18384, 1, 0}, //1271
        {5150, 3866, 5150 - 3866, 2916, 1, 0}, //1284
        {5150, 3842, 5150 - 3842, 29720, 1, 0}, //1308
        {5150, 3816, 5150 - 3816, 6660, 1, 0}, //1334
        {5150, 3807, 5150 - 3807, 3255, 1, 0}, //1343
        {5150, 3797, 5150 - 3797, 5063, 1, 0}, //1353
        {5150, 3789, 5150 - 3789, 7030, 1, 0}, //1361
        {5150, 3762, 5150 - 3762, 29720, 1, 0}, //1388
        {5150, 3723, 5150 - 3723, 2169, 1, 0}, //1427
        {5150, 3642, 5150 - 3642, 13333, 1, 0}, //1508
        {5150, 3632, 5150 - 3632, 2199, 1, 0}, //1518
        {5150, 3618, 5150 - 3618, 2169, 1, 0}, //1532
        {5150, 3614, 5150 - 3614, 3299, 1, 0}, //1536
    },
    //越星1号
    {
        {9750, 11421, 11421 - 9750, 18000, 0, 0}, //1671
        {9750, 11441, 11441 - 9750, 4340, 0, 0}, //1691
        {9750, 11471, 11471 - 9750, 2169, 0, 0}, //1721
        {9750, 11482, 11482 - 9750, 3599, 0, 0}, //1732
        {9750, 11546, 11546 - 9750, 27500, 0, 0}, //1796
        {9750, 11586, 11586 - 9750, 27500, 0, 0}, //1836
        {9750, 11622, 11622 - 9750, 20500, 0, 0}, //1872
        {9750, 11666, 11666 - 9750, 27500, 0, 0}, //1916
        {9750, 11895, 11895 - 9750, 2859, 0, 0}, //2145
        {10600, 12271, 12271 - 10600, 18000, 0, 0}, //1671
        {10600, 12291, 12291 - 10600, 4340, 0, 0}, //1691
        {10600, 12321, 12321 - 10600, 2169, 0, 0}, //1721
        {10600, 12332, 12332 - 10600, 3599, 0, 0}, //1732
        {10600, 12396, 12396 - 10600, 27500, 0, 0}, //1796
        {10600, 12436, 12436 - 10600, 27500, 0, 0}, //1836
        {10600, 12473, 12473 - 10600, 20500, 0, 0}, //1873
        {10600, 12516, 12516 - 10600, 27500, 0, 0}, //1916
        {10600, 12551, 12551 - 10600, 19110, 0, 0}, //1951
        {10600, 12596, 12596 - 10600, 27500, 0, 0}, //1996
        {10600, 12676, 12676 - 10600, 27500, 0, 0}, //2076
        {10600, 12745, 12745 - 10600, 2859, 0, 0}, //2145
        //
        {9750, 11421, 11421 - 9750, 18000, 1, 0}, //1671
        {9750, 11441, 11441 - 9750, 4340, 1, 0}, //1691
        {9750, 11471, 11471 - 9750, 2169, 1, 0}, //1721
        {9750, 11482, 11482 - 9750, 3599, 1, 0}, //1732
        {9750, 11546, 11546 - 9750, 27500, 1, 0}, //1796
        {9750, 11586, 11586 - 9750, 27500, 1, 0}, //1836
        {9750, 11622, 11622 - 9750, 20500, 1, 0}, //1872
        {9750, 11666, 11666 - 9750, 27500, 1, 0}, //1916
        {9750, 11895, 11895 - 9750, 2859, 1, 0}, //2145
        {10600, 12271, 12271 - 10600, 18000, 1, 0}, //1671
        {10600, 12291, 12291 - 10600, 4340, 1, 0}, //1691
        {10600, 12321, 12321 - 10600, 2169, 1, 0}, //1721
        {10600, 12332, 12332 - 10600, 3599, 1, 0}, //1732
        {10600, 12396, 12396 - 10600, 27500, 1, 0}, //1796
        {10600, 12436, 12436 - 10600, 27500, 1, 0}, //1836
        {10600, 12473, 12473 - 10600, 20500, 1, 0}, //1873
        {10600, 12516, 12516 - 10600, 27500, 1, 0}, //1916
        {10600, 12551, 12551 - 10600, 19110, 1, 0}, //1951
        {10600, 12596, 12596 - 10600, 27500, 1, 0}, //1996
        {10600, 12676, 12676 - 10600, 27500, 1, 0}, //2076
        {10600, 12745, 12745 - 10600, 2859, 1, 0}, //2145
    },
    //亚太2R
    {
        //H
        {5150, 4175, 5150 - 4175, 4285, 0, 0}, //975
        {5150, 4169, 5150 - 4169, 4285, 0, 0}, //981
        {5150, 4163, 5150 - 4163, 4340, 0, 0}, //987
        {5150, 4145, 5150 - 4145, 3600, 0, 0}, //1005
        {5150, 4136, 5150 - 4136, 3333, 0, 0}, //1014
        {5150, 4133, 5150 - 4133, 3750, 0, 0}, //1017
        {5150, 4126, 5150 - 4126, 4441, 0, 0}, //1024
        {5150, 4119, 5150 - 4119, 4444, 0, 0}, //1031
        {5150, 4113, 5150 - 4113, 3695, 0, 0}, //1037
        {5150, 4109, 5150 - 4109, 2000, 0, 0}, //1041
        {5150, 4105, 5150 - 4105, 3125, 0, 0}, //1045
        {5150, 4085, 5150 - 4085, 2530, 0, 0}, //1065
        {5150, 4070, 5150 - 4070, 13020, 0, 0}, //1080
        {5150, 4056, 5150 - 4056, 3212, 0, 0}, //1094
        {5150, 4049, 5150 - 4049, 4290, 0, 0}, //1101
        {5150, 4034, 5150 - 4034, 4300, 0, 0}, //1116
        {5150, 4016, 5150 - 4016, 4340, 0, 0}, //1134
        {5150, 4009, 5150 - 4009, 4290, 0, 0}, //1141
        {5150, 4004, 5150 - 4004, 4324, 0, 0}, //1146
        {5150, 3997, 5150 - 3997, 3190, 0, 0}, //1153
        {5150, 3985, 5150 - 3985, 3700, 0, 0}, //1165
        {5150, 3960, 5150 - 3960, 30000, 0, 0}, //1190
        {5150, 3920, 5150 - 3920, 28340, 0, 0}, //1230
        {5150, 3880, 5150 - 3880, 28125, 0, 0}, //1270
        {5150, 3840, 5150 - 3840, 27500, 0, 0}, //1310
        {5150, 3815, 5150 - 3815, 3333, 0, 0}, //1335
        {5150, 3811, 5150 - 3811, 3980, 0, 0}, //1339
        {5150, 3805, 5150 - 3805, 4340, 0, 0}, //1345
        {5150, 3799, 5150 - 3799, 4330, 0, 0}, //1351
        {5150, 3794, 5150 - 3793, 4444, 0, 0}, //1357
        {5150, 3787, 5150 - 3787, 4600, 0, 0}, //1363
        {5150, 3769, 5150 - 3769, 13333, 0, 0}, //1381
        {5150, 3750, 5150 - 3750, 5000, 0, 0}, //1400
        {5150, 3745, 5150 - 3745, 3125, 0, 0}, //1405
        {5150, 3720, 5150 - 3720, 29620, 0, 0}, //1430
        {5150, 3680, 5150 - 3680, 27500, 0, 0}, //1470
        {5150, 3648, 5150 - 3648, 6500, 0, 0}, //1502
        {5150, 3600, 5150 - 3600, 26999, 0, 0}, //1550
        {5150, 3568, 5150 - 3568, 1852, 0, 0}, //1582
        {5150, 3563, 5150 - 3563, 4443, 0, 0}, //1587
        {5150, 3551, 5150 - 3551, 13334, 0, 0}, //1599
        {5150, 3520, 5150 - 3520, 28130, 0, 0}, //1630
        {5150, 3440, 5150 - 3440, 26669, 0, 0}, //1710
        //V
        {5150, 4161, 5150 - 4161, 2000, 1, 0}, //989
        {5150, 4109, 5150 - 4109, 2000, 1, 0}, //1041
        {5150, 4031, 5150 - 4031, 6312, 1, 0}, //1119
        {5150, 3993, 5150 - 3993, 1481, 1, 0}, //1157
        {5150, 3958, 5150 - 3958, 1666, 1, 0}, //1192
        {5150, 3765, 5150 - 3765, 5900, 1, 0}, //1385
        {5150, 3755, 5150 - 3755, 4640, 1, 0}, //1395
        {5150, 3747, 5150 - 3747, 8000, 1, 0}, //1403
        {5150, 3705, 5150 - 3705, 8888, 1, 0}, //1445
        {5150, 3463, 5150 - 3463, 2857, 1, 0}, //1687
        {5150, 3458, 5150 - 3458, 2222, 1, 0}, //1692
        {5150, 3426, 5150 - 3426, 2592, 1, 0}, //1724
        {5150, 3419, 5150 - 3419, 3332, 1, 0}, //1731
        {5150, 3415, 5150 - 3415, 2915, 1, 0}, //1735
        {5150, 3409, 5150 - 3409, 4444, 1, 0}, //1741
    },
    //亚洲3S
    {
        {5150, 4177, 5150 - 4177,   2444,   0, 0}, //973
        {5150, 4172, 5150 - 4172,   2480,   0, 0}, //978
        {5150, 4165, 5150 - 4165,   5710,   0, 0}, //985
        {5150, 4160, 5150 - 4160,   3030,   0, 0}, //990
        {5150, 4154, 5150 - 4154,   5632,   0, 0}, //996
        {5150, 4146, 5150 - 4146,   4000,   0, 0}, //1004
        {5150, 4132, 5150 - 4132,   9200,   0, 0}, //1018
        {5150, 4097, 5150 - 4097,   2256,   0, 0}, //1053
        {5150, 4071, 5150 - 4071,   14240,  0, 0}, //1079
        {5150, 4040, 5150 - 4040,   26500,  0, 0}, //1110
        {5150, 4000, 5150 - 4000,   26850,  0, 0}, //1150
        {5150, 3960, 5150 - 3960,   27500,  0, 0}, //1190
        {5150, 3880, 5150 - 3880,   27500,  0, 0}, //1270
        {5150, 3760, 5150 - 3760,   26000,  0, 0}, //1390
        {5150, 3706, 5150 - 3706,   6000,   0, 0}, //1444
        //
        {5150, 4176, 5150 - 4176,   2433,   1, 0}, //974
        {5150, 4173, 5150 - 4173,   2480,   1, 0}, //977
        {5150, 4166, 5150 - 4166,   5700,   1, 0}, //984
        {5150, 4160, 5150 - 4160,   5700,   1, 0}, //990
        {5150, 4154, 5150 - 4154,   5631,   1, 0}, //996
        {5150, 4147, 5150 - 4147,   4000,   1, 0}, //1003
        {5150, 4132, 5150 - 4132,   9200,   1, 0}, //1018
        {5150, 4097, 5150 - 4097,   2309,   1, 0}, //1053
        {5150, 4072, 5150 - 4072,   14240,  1, 0}, //1053
        {5150, 4041, 5150 - 4041,   26624,  1, 0}, //1109
        {5150, 4001, 5150 - 4001,   26850,  1, 0}, //1149
        {5150, 3960, 5150 - 3960,   27500,  1, 0}, //1190
        {5150, 3881, 5150 - 3881,   27500,  1, 0}, //1269
        {5150, 3761, 5150 - 3761,   25999,  1, 0}, //1389
        {5150, 3707, 5150 - 3707,   6000,   1, 0}, //1443
    },
#endif

};


#endif

static const UINT8 MAP_BETA_ACTIVE_BUF[32] =
{
    0x00,   //                           //index 0, do not use
    0x01,   // 1/4 of QPSK        //1
    0x01,   // 1/3                      //2
    0x01,   // 2/5                      //3
    0x01,   // 1/2                      //4
    0x01,   // 3/5                      //5
    0x01,   // 2/3                      //6
    0x01,   // 3/4                      //7
    0x01,   // 4/5                      //8
    0x01,   // 5/6                      //9
    0x01,   // 8/9                      //a
    0x01,   // 9/10                     //b
    0x01,   // 3/5 of 8PSK           //c
    0x01,   // 2/3                      //d
    0x01,   // 3/4                      //e
    0x01,   // 5/6                      //f
    0x01,   // 8/9                      //10
    0x01,   // 9/10                     //11
    0x01,   // 2/3 of 16APSK        //12
    0x01,   // 3/4                      //13
    0x01,   // 4/5                      //14
    0x01,   // 5/6                      //15
    0x01,   // 8/9                      //16
    0x01,   // 9/10                     //17
    0x01,   // for 32 APSK, dont use
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
};

static const UINT8 MAP_BETA_BUF[32] =
{
    188,   //  205,     // index 0, do not use
    188,   //  205,     // 1/4 of QPSK    //1
    190,   //  230,     // 1/3                      //2
    205,   //  205,     // 2/5                      //3
    205,   //  205,     // 1/2                      //4
    180,   //  180,     // 3/5                      //5
    180,   //  180,     // 2/3                      //6
    180,   //  180,     // 3/4                      //7
    155,   //  180,     // 4/5                      //8
    168,   //  180,     // 5/6                      //9
    150,   //  155,     // 8/9                      //a
    150,   //  155,     // 9/10                     //b
    180,   //  180,     // 3/5 of 8PSK           //c
    180,   //  180,     // 2/3                      //d
    170,   //  180,     // 3/4                      //e
    180,   //  155,     // 5/6                      //f
    150,   //  155,     // 8/9                      //10
    150,   //  155,     // 9/10                     //11
    180,   //  205,     // 2/3 of 16APSK        //12
    180,   //  180,     // 3/4                      //13
    180,   //  180,     // 4/5                      //14
    170,   //  155,     // 5/6                      //15
    155,   //  155,     // 8/9                      //16
    155,   //  155,     // 9/10                     //17
    155,        //---------------------    for 32 APSK, dont use
    155, 155, 155, 155, 155, 155, 155
};
static const UINT16 DEMAP_NOISE[32] =
{
    0x00,       // index 0, do not use
    0x16b,      // 1/4 of QPSK          //1
    0x1d5,      // 1/3                      //2
    0x246,      // 2/5                      //3
    0x311,      // 1/2                      //4
    0x413,      // 3/5                      //5
    0x4fa,      // 2/3                      //6
    0x62b,      // 3/4                      //7
    0x729,      // 4/5                      //8
    0x80c,      // 5/6                      //9
    0xa2a,      // 8/9                      //a
    0xab2,      // 9/10                     //b
    0x8a9,      // 3/5 of 8PSK           //c
    0xb31,      // 2/3                      //d
    0xf1d,   // 3/4                      //e
    0x1501,     // 5/6                      //f
    0x1ca5,       // 8/9                      //10
    0x1e91,       // 9/10                     //11
    0x133b,       // 2/3 of 16APSK        //12
    0x199a,       // 3/4                      //13
    0x1f08,       // 4/5                      //14
    0x234f,       // 5/6                      //15
    0x2fa1,       // 8/9                      //16
    0x3291,        // 9/10                     //17
    0x00,        // for 32 APSK, dont use
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const UINT16 SNR_THR[TAB_SIZE * 2] =
{
    640, 670, // 6
    576, 615, // 6.5
    525, 563, // 7
    479, 513, // 7.5
    436, 468, // 8
    397, 426, // 8.5
    360, 388, // 9
    328, 351, // 9.5
    297, 319, // 10
    267, 289, // 10.5
    242, 261,  // 11
    219, 234,  // 11.5
    198, 213, // 12
    120, 193 // 12.5
};
static const UINT16 cr_para_8psk_3f5[TAB_SIZE] =
{
    0x14b0,  //6
    0x14b0,  //6.5
    0x14b0,  //7
    0x13a0,  //7.5
    0x129a,  //8
    0x1295,  //8.5
    0x1295,  //9
    0x1295,  //9.5
    0x1295,  //10
    0x1295,  // 10.5
    0x1295,  // 11
    0x1295,  // 11.5
    0x1290,  // 12
    0x1290   // 12.5
};
static const UINT16 cr_para_8psk_others[TAB_SIZE] =
{
    0x14b0, // 6
    0x14b0, // 6.5
    0x14b0, // 7
    0x13b0, // 7.5
    0x13a0, // 8
    0x13a0, // 8.5
    0x129a, // 9
    0x129a, // 9.5
    0x1295, // 10
    0x1295,  // 10.5
    0x1295, // 11
    0x1295, // 11.5
    0x1290, // 12
    0x1290  // 12.5
};
static const UINT32 agc_table[256] =
{
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   2,   3,   4,   5, \
    6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21, \
    22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37, \
    38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  52,  55,  57, \
    60,  62,  65,  67,  70,  72,  75,  77,  78,  79,  80,  82,  83,  84,  85,  87, \
    88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 101, 102, 103, 104, 105, 106, \
    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, \
    123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, \
    139, 140, 141, 142, 144, 145, 146, 147, 149, 150, 151, 152, 154, 155, 156, 157, \
    159, 160, 161, 162, 164, 165, 166, 167, 169, 170, 171, 173, 175, 176, 178, 180, \
    182, 184, 187, 189, 192, 194, 197, 199, 202, 204, 207, 209, 212, 215, 218, 222, \
    225, 228, 232, 235, 238, 242, 245, 248, 252, 255, 258, 262, 265, 268, 272, 275, \
    278, 282, 285, 288, 292, 295, 298, 302, 305, 308, 312, 317, 322, 327, 332, 337, \
    342, 347, 352, 357, 362, 367, 372, 377, 382, 387, 392, 397, 402, 407, 412, 417, \
    422, 427, 432, 437, 442, 447, 452, 457, 462, 467, 472, 477, 482, 487, 492, 493, \
    494, 495, 496, 497, 498, 499, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, \
};


static UINT8 old_cr_para[2] = {0, 0};
static INT32 curr_snr_idx = 0;
static UINT16 snr_lpf = 0;
static INT32 interval_cnt = 0;
static UINT16 snr_max = 0;
static UINT16 snr_min = 0;
static UINT32 ber_sum = 0;
static UINT32 last_ber_sum = 0;
static UINT32 cur_ber_sum = 0;
static UINT32 ber_thres = 0x180;
static UINT8 cur_max_iter = 50;
static UINT8 snr_bak = 0;
static UINT8 last_max_iter = 50;
static INT32 cnt3 = 0;

void nim_s3501_set_fft_para(struct nim_device *dev)
{
    return;
}
#if 0
static INT32 nim_m3501c_disable_soft_cbr (struct nim_device *dev)
{
    return SUCCESS;
}

static INT32 nim_m3501c_enable_soft_cbr (struct nim_device *dev)
{
    return SUCCESS;
}
#endif

#ifdef NIM_3501_FUNC_EXT

static INT32 nim_s3501_s2_get_ber(struct nim_device *dev, UINT32 *rsubc)
{
    UINT8 data, rdata;
    UINT8 ber_data[3];
    UINT32 u32ber_data[3];
    UINT32 uber_data;

    nim_reg_read(dev, RD3_BER_REG, &rdata, 1);
    data = rdata & 0x7b;
    nim_reg_write(dev, RD3_BER_REG, &data, 1);

    nim_reg_read(dev, RD3_BER_REG + 0x01, &ber_data[0], 1);
    u32ber_data[0] = (UINT32) ber_data[0];
    nim_reg_read(dev, RD3_BER_REG + 0x01, &ber_data[1], 1);
    u32ber_data[1] = (UINT32) ber_data[1];
    u32ber_data[1] <<= 8;
    uber_data = u32ber_data[1] + u32ber_data[0];
    *rsubc = uber_data;

    return SUCCESS;
}

static INT32 nim_get_symbol(struct nim_device *dev)
{
    UINT8 data;
    UINT32 i;

    for (i = 0; i < 5000; i++)
    {
        data = 0xc1;
        nim_reg_write(dev, RC8_BIST_TOLERATOR, &data, 1);
        nim_reg_read(dev, RC9_CR_OUT_IO_RPT, &data, 1);
        NIM_PRINTF("%02x", data);
        nim_reg_read(dev, RC9_CR_OUT_IO_RPT + 0x01, &data, 1);
        NIM_PRINTF("%02x\n", data);
    }
    data = 0xc0;
    nim_reg_write(dev, RC8_BIST_TOLERATOR, &data, 1);
}

static UINT8 reg_read_find_index(INT32 i)
{
    UINT8 m_index_list[]=
       {
        0x03,0x04,0x0b,0x0c,0x11,0x12,0x26,0x27,0x45,0x46,0x55,0x56,0x5a,0x68,0x69,0x6a,
        0x6b,0x6c,0x6d,0x6e,0x6f,0x72,0x73,0x7d,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,
        0x9d,0xa3,0xa4,0xa5,0xa6,0xaa,0xab,0xac,0xb2 ,0xb1,0xb4,0xba,0xbb,0xbc,0xc0,0xc1,
        0xc4,0xc2,0xc3
    }
    INT32 j=0;
    INT32 count=sizeof(m_index_list)/sizeof(UINT8);
    for(j=0; j<count;j++)
    {
        if(i == m_index_list[j])
        {
            return 1;
        }
    }

    return 0;

}

void reg_read_verification(struct nim_device *dev)
{
    UINT8 ver_data =0 ;
    UINT8 ret_found =0;
    INT32 i, j, k;


    UINT8 m_reg_list[192] =
    {
        0x11, 0x00, 0x00, 0x0f, 0x00, 0x5a, 0x50, 0x2f, 0x48, 0x3f, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x83, 0x00, 0x00, 0xec, 0x17, 0x1e, 0x17, 0xec, 0x6b, 0x8e, 0xb1, 0x28, 0xba, 0x0c, 0x60, 0x00,
    0x03, 0x05, 0x00, 0x20, 0x10, 0x04, 0x00, 0x00, 0xe3, 0x88, 0x4f, 0x2d, 0x68, 0x06, 0x5a, 0x10,
    0x77, 0xe5, 0x24, 0xaa, 0x45, 0x87, 0x51, 0x52, 0xba, 0x46, 0x80, 0x3e, 0x25, 0x14, 0x28, 0x3f,
    0xc0, 0x00, 0x02, 0x83, 0x00, 0x00, 0x00, 0x7f, 0x98, 0x48, 0x38, 0x58, 0xc2, 0x12, 0xd2, 0x00,
    0x10, 0x27, 0x60, 0xea, 0x71, 0x00, 0x00, 0x32, 0x10, 0x08, 0x00, 0x73, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0xb0, 0x30, 0x30, 0x59, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x50,
    0x5a, 0x57, 0x0b, 0x45, 0xc6, 0x41, 0x3c, 0x04, 0x20, 0x70, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x35, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x7c, 0x21, 0x04, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00
    };


    for (i = 0; i <= 0xc7; i++)
    {
        ret_found= reg_read_find_index(i);
        if(!ret_found)
        {
            for (j = 0; j < 1000; j++)
            {
                nim_reg_read(dev, i, &ver_data, 1);
                for (k = 0; k < 1000; k++)
                {
                    j = j;
                }
                if (ver_data != m_reg_list[i])
                {
                    NIM_PRINTF(" read reg number :0x%x ; ver_data :0x%x ,reg_list_data : 0x%x\n", i,
                      ver_data, m_reg_list[i]);
                }
            }
        }
    }
    NIM_PRINTF("finish register read test\n");

    return;
}

static UINT8 reg_write_find_index(INT32 i)
{
    UINT8 m_index_list[]=
       {
        0x00 ,0xb1 ,0x04 ,0x0b ,0x0c ,0x11 ,0x12 ,0x26 ,0x27 ,0x45 ,0x46 ,0x55 ,0x56 ,0x5a ,0x68 ,0x69 ,
        0x6a ,0x6b ,0x6c ,0x6d ,0x6e ,0x6f ,0x72 ,0x73 ,0x7d ,0x86 ,0x87 ,0x88 ,0x89 ,0x8a ,0x8b ,0x8c ,
        0x8d ,0x9d ,0xa3 ,0xa4 ,0xa5 ,0xa6 ,0xaa ,0xab ,0xac ,0xb2 ,0xb3 ,0xb4 ,0xba ,0xbb ,0xbc ,0xc2 ,
        0xc3 ,0xc4
    }
    INT32 j=0;
    INT32 count=sizeof(m_index_list)/sizeof(UINT8);
    for(j=0; j<count;j++)
    {
        if(i == m_index_list[j])
        {
            return 1;
        }
    }

    return 0;

}


void reg_write_verification(struct nim_device *dev)
{
    UINT8 ver_data =0;
    UINT8 ret_found =0;
    UINT8 write_data;
    INT32 i;

    for (i = 0x0; i <= 0xc7; i++)
    {
        ret_found= reg_write_find_index(i);
        if(!ret_found)
        {
            NIM_PRINTF(" i=%d\n", i);
            write_data = 0x5a;
            nim_reg_write(dev, i, &write_data, 1);
            nim_reg_read(dev, i, &ver_data, 1);

            if (ver_data != write_data)
            {
                NIM_PRINTF(" write reg number :0x%x ; write data : %x; ver_data :0x%x\n", i, write_data, ver_data);
            }
            write_data = 0xa6;
            nim_reg_write(dev, i, &write_data, 1);

            nim_reg_read(dev, i, &ver_data, 1);
            if (ver_data != write_data)
            {
                NIM_PRINTF(" write reg number :0x%x  ; write data : %x; ver_data :0x%x\n", i, write_data, ver_data);
            }
        }
    }
    NIM_PRINTF("reg_write_verfication all finish\n");
    return;
}

static INT32 nim_invert_moclk_phase(struct nim_device *dev)
{
    UINT8 data;
    nim_reg_read(dev, RD8_TS_OUT_SETTING, &data, 1);
    data = data ^ 0x08;
    nim_reg_write(dev, RD8_TS_OUT_SETTING, &data, 1);
    return SUCCESS;
}

static INT32 nim_open_ssi_debug(struct nim_device *dev)
{
    UINT8 data;
    nim_reg_read(dev, RD8_TS_OUT_SETTING, &data, 1);
    data = data | 0x20;
    nim_reg_write(dev, RD8_TS_OUT_SETTING, &data, 1);
    return SUCCESS;
}

static INT32 nim_close_ssi_debug(struct nim_device *dev)
{
    UINT8 data;
    nim_reg_read(dev, RD8_TS_OUT_SETTING, &data, 1);
    data = data & 0xdf;
    nim_reg_write(dev, RD8_TS_OUT_SETTING, &data, 1);
    return SUCCESS;
}

static INT32 nim_open_ts_dummy(struct nim_device *dev)
{
    UINT8 data;
    nim_reg_read(dev, RD8_TS_OUT_SETTING, &data, 1);
    data = data | 0x10;
    nim_reg_write(dev, RD8_TS_OUT_SETTING, &data, 1);
    return SUCCESS;
}

static INT32 nim_s3501_set_dmy_format(struct nim_device *dev)
{
    UINT8 data, tmp;
    //enable ECO_TS_DYM_HEAD_EN = bf[7];
    nim_reg_read(dev, RBF_S2_FEC_DBG, &data, 1);
    data = data | 0x80;
    nim_reg_write(dev, RBF_S2_FEC_DBG, &data, 1);

    //enable ECO_TS_DYM_HEAD_0 = {a2[7:3],a1[7:5]} = 47;
    nim_reg_read(dev, RA0_RXADC_REG + 0x02, &data, 1);
    tmp = TS_DYM_HEAD0 & 0xf8;
    data = (data & 0x07) | tmp;
    nim_reg_write(dev, RA0_RXADC_REG + 0x02, &data, 1);
    nim_reg_read(dev, RA0_RXADC_REG + 0x01, &data, 1);
    tmp = TS_DYM_HEAD0 & 0x07;
    tmp = (tmp << 5) & 0xff;
    data = (data & 0x1f) | tmp;
    nim_reg_write(dev, RA0_RXADC_REG + 0x01, &data, 1);

    //enable ECO_TS_DYM_HEAD_1 = {ce[7:4],a9[1:0],a8[1:0]} = 1f;
    nim_reg_read(dev, RCE_TS_FMT_CLK, &data, 1);
    tmp = TS_DYM_HEAD1 & 0xf0;
    data = (data & 0x0f) | tmp;
    nim_reg_write(dev, RCE_TS_FMT_CLK, &data, 1);
    nim_reg_read(dev, RA9_M180_CLK_DCHAN, &data, 1);
    tmp = TS_DYM_HEAD1 & 0x0c;
    tmp = (tmp >> 2) & 0xff;
    data = (data & 0xfc) | tmp;
    nim_reg_write(dev, RA9_M180_CLK_DCHAN, &data, 1);
    nim_reg_read(dev, RA8_M90_CLK_DCHAN, &data, 1);
    tmp = TS_DYM_HEAD1 & 0x03;
    data = (data & 0xfc) | tmp;
    nim_reg_write(dev, RA8_M90_CLK_DCHAN, &data, 1);

    //enable ECO_TS_DYM_HEAD_2 = {c1[7:2],cc[7:6]} = ff;
    nim_reg_read(dev, RC1_DVBS2_FEC_LDPC, &data, 1);
    tmp = TS_DYM_HEAD2 & 0xfc;
    data = (data & 0x03) | tmp;
    nim_reg_write(dev, RC1_DVBS2_FEC_LDPC, &data, 1);
    nim_reg_read(dev, RCC_STRAP_PIN_CLOCK, &data, 1);
    tmp = TS_DYM_HEAD2 & 0x03;
    tmp = (tmp << 6) & 0xff;
    data = (data & 0x3f) | tmp;
    nim_reg_write(dev, RCC_STRAP_PIN_CLOCK, &data, 1);

    //enable ECO_TS_DYM_HEAD_3 = {cf[7:1],c0[1]} = 10;
    nim_reg_read(dev, RCE_TS_FMT_CLK + 0x01, &data, 1);
    tmp = TS_DYM_HEAD3 & 0xfe;
    data = (data & 0x01) | tmp;
    nim_reg_write(dev, RCE_TS_FMT_CLK + 0x01, &data, 1);
    nim_reg_read(dev, RC0_BIST_LDPC_REG, &data, 1);
    tmp = TS_DYM_HEAD3 & 0x01;
    tmp = (tmp << 1) & 0xff;
    data = (data & 0xfd) | tmp;
    nim_reg_write(dev, RC0_BIST_LDPC_REG, &data, 1);

    //enable ECO_TS_DYM_HEAD_4 = {9f[7:4],92[7:4]} = 00;
    nim_reg_read(dev, R9C_DEMAP_BETA + 0x03, &data, 1);
    tmp = TS_DYM_HEAD4 & 0xf0;
    data = (data & 0x0f) | tmp;
    nim_reg_write(dev, R9C_DEMAP_BETA + 0x03, &data, 1);
    nim_reg_read(dev, R90_DISEQC_CLK_RATIO + 0x02, &data, 1);
    tmp = TS_DYM_HEAD4 & 0x0f;
    tmp = (tmp << 4) & 0xff;
    data = (data & 0x0f) | tmp;
    nim_reg_write(dev, R90_DISEQC_CLK_RATIO + 0x02, &data, 1);

    return SUCCESS;
}

INT32 nim_s3501_get_phase_error(struct nim_device *dev, INT32 *phase_error)
{
    UINT8 rdata = 0;
    UINT8 data = 0;

    nim_reg_read(dev, RC0_BIST_LDPC_REG + 4, &data, 1);
    if (data & 0x80)
    {
        data &= 0x7f;
        nim_reg_write(dev, RC0_BIST_LDPC_REG + 4, &data, 1);
    }
    nim_reg_read(dev, RC0_BIST_LDPC_REG, &data, 1);
    if ((data & 0x04) == 0)
    {
        nim_reg_read(dev, RC0_BIST_LDPC_REG + 5, &rdata, 1);
        data |= 0x04;
        nim_reg_write(dev, RC0_BIST_LDPC_REG, &data, 1);
        if (rdata & 0x80)
            *phase_error = rdata - 256;
        else
            *phase_error = rdata;
        NIM_PRINTF("phase error is %d\n", (*phase_error));
        return SUCCESS;
    }
    else
    {
        *phase_error = 0;
        return ERR_FAILUE;
    }
}
#endif



static void nim_s3501_after_reset_set_param_x(struct nim_device *dev)
{
    UINT8 data = 0;
    struct nim_s3501_private *priv =NULL; 

	if(dev == NULL)
    {
	   return;
	}   
	priv = (struct nim_s3501_private *) dev->priv;   
    if((priv->ul_status.m_tso_mode == 1))
    {
        data = 0x13;
        nim_reg_write(dev, RF0_HW_TSO_CTRL, &data, 1);

        data = 0x08;
        nim_reg_write(dev, RF1_DSP_CLK_CTRL, &data, 1);

        if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_2BIT_MODE)
        {
            data = 0x00;
            nim_reg_write(dev, RF0_HW_TSO_CTRL + 6, &data, 1);
        }
        else
        {
            // Invert MOCLK
            data = 0x01;
            nim_reg_write(dev, RF0_HW_TSO_CTRL + 6, &data, 1);
        }

#ifdef C3501C_ERRJ_LOCK
        nim_m3501c_invert_moerrj(dev);
#endif
        // Enable TSO_RESET_LEVEL
        data = 0xef;
        nim_reg_write(dev, RFF_TSO_CLS, &data, 1);

        nim_m3501c_fec_ts_on(dev);

        if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_1BIT_MODE)
        {
            data = 0xc0;
         }
        else if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_2BIT_MODE)
        {
           data = 0x00;
         }
        else if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_4BIT_MODE)
        {
           data = 0x40;
        }
        else
        {
          data = 0x80;
         }
        nim_reg_write(dev, RC0_BIST_LDPC_REG, &data, 1);

        if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_1BIT_MODE)
        {
           data = 0x70;
        }
        else if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_2BIT_MODE)
        {
          data = 0x11;
        }
        else if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_4BIT_MODE)
        {
          data = 0x32;
        }
        else
        {
          data = 0x50;
        }
        data = data | 0x80;
        nim_reg_write(dev, RBD_CAP_PRM, &data, 1); //set ts_port enable

        // FEC use SPI output to TSO, use fast speed
        data = 0xc0;
        nim_reg_write(dev, RAD_TSOUT_SYMB + 1, &data, 1);
        data = 0x02;
        nim_reg_write(dev, RAD_TSOUT_SYMB, &data, 1);
    }
    else
    {
        data = 0x10;
        nim_reg_write(dev, RF0_HW_TSO_CTRL, &data, 1);
        if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_1BIT_MODE)
        {
           data = 0x70;
         }
        else if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_2BIT_MODE)
        {
          data = 0x11;
         }
        else if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_4BIT_MODE)
        {
          data = 0x32;
        }
        else
        {
           data = 0x50;
        }
        nim_reg_write(dev, RBD_CAP_PRM, &data, 1);

        if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_2BIT_MODE)
        {
            data = 0xf1;
            nim_reg_write(dev, R54_VITERBI_FRAME_SYNC, &data, 1);

            data = 0x0e;
            nim_reg_write(dev, RD8_TS_OUT_SETTING, &data, 1);
            data = 0x00;
            nim_reg_write(dev, RF0_HW_TSO_CTRL + 6, &data, 1);
        }
        else
        {
            data = 0x71;
            nim_reg_write(dev, R54_VITERBI_FRAME_SYNC, &data, 1);
            data = 0x06;
            nim_reg_write(dev, RD8_TS_OUT_SETTING, &data, 1);
            data = 0x00;
            nim_reg_write(dev, RF0_HW_TSO_CTRL + 6, &data, 1);
        }
    }

}



void nim_s3501_after_reset_set_param(struct nim_device *dev)
{
    UINT8 data = 0;
    UINT32 data_tmp = 0;
    INT32 i = 0;
    struct nim_s3501_private *priv =NULL;
    
    if(dev == NULL)
    {
	   return;
	}   
	priv = (struct nim_s3501_private *) dev->priv;
    NIM_PRINTF(" Current version is %s\n",VERSION_S3501);
    NIM_PRINTF("Enter nim_s3501_after_reset_set_param:\n");
    nim_s3501_demod_ctrl(dev, NIM_DEMOD_CTRL_0X91);

    nim_s3501_interrupt_mask_clean(dev);

    data = 0x50;
    nim_reg_write(dev, R0A_AGC1_LCK_CMD, &data, 1);

    // set diseqc clock.
    nim_s3501_get_dsp_clk(dev, &data_tmp);
    // Set diseqc parameter
    data = ((data_tmp + 500) / 1000);
    nim_reg_write(dev, R90_DISEQC_CLK_RATIO, &data, 1);

    // set unconti timer
    data = 0x40;
    nim_reg_write(dev, RBA_AGC1_REPORT, &data, 1);

    //set receive timer: 0x88 for default;
    data = 0x88;
    nim_reg_write(dev, R8E_DISEQC_TIME, &data, 1);
    data = 0xff;
    nim_reg_write(dev, R8E_DISEQC_TIME + 0x01, &data, 1);

    if (priv->ul_status.m_s3501_type == NIM_CHIP_ID_M3501B)
    {

        if((priv->ul_status.m_s3501_sub_type == NIM_CHIP_SUB_ID_M3501C))
        {
#ifdef DISEQC_OUT_INVERT
            data = 0xbc;
            nim_reg_write(dev, R90_DISEQC_CLK_RATIO + 6, &data, 1);
#endif

            // TSO setting
            // Disable TSO OEJ
            data = 0x6f;
            nim_reg_write(dev, RF0_HW_TSO_CTRL + 5, &data, 1);

            nim_s3501_after_reset_set_param_x(dev);

        }
        else
        {
            if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_1BIT_MODE)
            {
               data = 0x70;
             }
            else if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_2BIT_MODE)
            {
               data = 0x11;
             }
            else if ((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_4BIT_MODE)
            {
              data = 0x32;
            }
            else
            {
              data = 0x50;
            }
            nim_reg_write(dev, RBD_CAP_PRM, &data, 1);

            if((priv->tuner_config_data.qpsk_config & 0xc0) == M3501_2BIT_MODE)
            {
                data = 0xf1;
                nim_reg_write(dev, R54_VITERBI_FRAME_SYNC, &data, 1);
                data = 0x0e;
                nim_reg_write(dev, RD8_TS_OUT_SETTING, &data, 1);
            }
            else
            {
                data = 0x71;
                nim_reg_write(dev, R54_VITERBI_FRAME_SYNC, &data, 1);
                data = 0x06;
                nim_reg_write(dev, RD8_TS_OUT_SETTING, &data, 1);
            }
        }

        for (i = 0; i < 32; i++)
        {
            data = i;
            nim_reg_write(dev, R9C_DEMAP_BETA + 0x02, &data, 1);
            data = MAP_BETA_ACTIVE_BUF[i];
            nim_reg_write(dev, R9C_DEMAP_BETA, &data, 1);
            data = 0x04;
            nim_reg_write(dev, R9C_DEMAP_BETA + 0x03, &data, 1);
            data = MAP_BETA_BUF[i];
            nim_reg_write(dev, R9C_DEMAP_BETA, &data, 1);
            data = 0x03;
            nim_reg_write(dev, R9C_DEMAP_BETA + 0x03, &data, 1);
        }

    }
    return ;
}







#if 0
static void nim_s3501_set_demap_noise(struct nim_device *dev)
{
    UINT8 data = 0;
    UINT8 noise_index = 0;
    UINT16 est_noise = 0;

    if(dev == NULL)
    {
	   return;
	}   
    // activate noise
    nim_reg_read(dev, RD0_DEMAP_NOISE_RPT + 2, &data, 1);
    data &= 0xfc;
    nim_reg_write(dev, RD0_DEMAP_NOISE_RPT + 2, &data, 1);

    // set noise_index
    noise_index = 0x0c;
    nim_reg_write(dev, RD0_DEMAP_NOISE_RPT + 1, &noise_index, 1);

    // set noise
    est_noise = DEMAP_NOISE[noise_index];
    data = est_noise & 0xff;
    nim_reg_write(dev, RD0_DEMAP_NOISE_RPT, &data, 1);
    data = (est_noise >> 8) & 0x3f;
    data |= 0xc0;
    nim_reg_write(dev, RD0_DEMAP_NOISE_RPT + 1, &data, 1);
}
#endif



INT32 nim_sw_adaptive_cr(struct nim_device *dev)
{
    UINT8 data = 0;
    UINT16 var = 0;
    INT8 snr_chg = 0;
    INT16 i = 0;

    UINT16 cr_data = 0;
    UINT8 frac = 0;
    UINT8 prs = 0;
    UINT8 irs = 0;
    UINT16 *cr_para = NULL;

    if(dev == NULL)
    {
	   return RET_FAILURE;
	}   
    nim_reg_read(dev, RBC_SNR_RPT2, &data, 1);
    if (data & 0x80)
    {
        var = (data & 0x0f) << 6;
        nim_reg_read(dev, RBB_SNR_RPT1, &data, 1);
        var += (data >> 2) & 0x03f;

        if(s3501_snr_initial_en)
        {
            snr_lpf = var;
        }
        else
        {
            snr_lpf = (snr_lpf * 7 + var) >> 2;
            snr_lpf += 1;
            snr_lpf >>= 1;
        }
        interval_cnt++;
        if(interval_cnt == INTERVAL_CNT_16)
        {
            interval_cnt = 0;
        }

        if(s3501_snr_initial_en)
        {
            curr_snr_idx = TAB_SIZE - 1;
            for(i = TAB_SIZE - 1; i >= 0; i--)
            {
                if(var >= SNR_THR[i * 2])
                {
                   curr_snr_idx = i;
                }
                else
                {
                   break;
                }
            }

            s3501_snr_initial_en = 0;
            snr_chg = 1;
            snr_lpf = var;
        }
        else if(curr_snr_idx > 0 && snr_lpf >= SNR_THR[2 * (curr_snr_idx - 1)] && (interval_cnt == 0))
        {
            curr_snr_idx--;
            snr_chg = 1;
        }
        else if(curr_snr_idx < TAB_SIZE - 1 && snr_lpf <= SNR_THR[2 * curr_snr_idx + 3] && (interval_cnt == 0))
        {
            curr_snr_idx++;
            snr_chg = 1;
        }

        if(snr_chg)
        {
            cr_para = (UINT16 *)cr_para_8psk_3f5;

            cr_data = cr_para[curr_snr_idx];
            frac = cr_data & 0x0f;
            prs = (cr_data >> 4) & 0x0f;
            irs = (cr_data >> 8) & 0x1f;
            data = (((irs & 0x03) << 4) | frac) << 2;
            nim_reg_write(dev, RBB_SNR_RPT1, &data, 1);

            data = ((irs >> 2) << 4) | prs | 0x80;
            nim_reg_write(dev, RBC_SNR_RPT2, &data, 1);

            data = 0xe8;
            nim_reg_write(dev, R0E_ADPT_CR_CTRL, &data, 1);


            data = (curr_snr_idx & 0x01) ? 5 : 0;
            NIM_PRINTF("--->switch to %d.%d dB Setting \n", (int)(6 + curr_snr_idx / 2), data);
        }

        data = 0x00;
        nim_reg_write(dev, RBC_SNR_RPT2, &data, 1);

    }

    return SUCCESS;
}




INT32 nim_cr_tab_init(struct nim_device *dev)
{
    UINT8 tabid = 0;
    UINT8 cellid =0;
    UINT16 tabval = 0;
    UINT16 tabvatemp = 0;
    UINT8 data = 0;
    UINT8 datarray[2] ={0};
    const UINT16 *pcrpara=NULL;
    const UINT16 others_tab[4] = {0x29,     0x00,      0x002,   0x01F8};

    if(dev == NULL)
    {
	   return RET_FAILURE;
	}   

#ifdef HW_ADPT_CR_MONITOR
    NIM_PRINTF("CR TAB Initialization Begin \n");
#endif
    data = 0xe1;
    nim_reg_write(dev, R0E_ADPT_CR_CTRL, &data, 1);

    for(cellid = 0; cellid < TAB_SIZE; cellid++)
    {
        nim_reg_write(dev, R9D_RPT_DEMAP_BETA, &cellid, 1);
        tabval = SNR_THR[2 * cellid] & 0x0fff;
        datarray[0] = (UINT8)(tabval & 0x0ff);
        datarray[1] = (UINT8)(((tabval >> 8) & 0x0ff) | 0x10);
        nim_reg_write(dev, R11_DCC_OF_I, datarray, 2);
    }

    for(cellid = 0; cellid < TAB_SIZE; cellid++)
    {
        data = 0x10 | cellid;
        nim_reg_write(dev, R9D_RPT_DEMAP_BETA, &data, 1);

        tabval = SNR_THR[2 * cellid + 1] & 0x0fff;
        datarray[0] = (UINT8)(tabval & 0x0ff);
        datarray[1] = (UINT8)(((tabval >> 8) & 0x0ff) | 0x10);
        nim_reg_write(dev, R11_DCC_OF_I, datarray, 2);
    }




    for(tabid = 2; tabid <= 7; tabid++)
    {
        if(tabid == TAB_ID_2)
        {
           pcrpara = cr_para_8psk_3f5;
        }
        else
        {
           pcrpara = cr_para_8psk_others;
         }

        for(cellid = 0; cellid < TAB_SIZE; cellid++)
        {
            data = (tabid << 4) | cellid;
            nim_reg_write(dev, R9D_RPT_DEMAP_BETA, &data, 1);

            tabval = pcrpara[cellid] & 0x1fff;
            tabvatemp = (tabval & 3) << 9;
            tabval = (tabval >> 4) | tabvatemp;
            datarray[0] = (UINT8)(tabval & 0x0ff);
            datarray[1] = (UINT8)(((tabval >> 8) & 0x0ff) | 0x10);
            nim_reg_write(dev, R11_DCC_OF_I, datarray, 2);
        }
    }


    // ON/OFF Table
    for(cellid = 0; cellid < 4; cellid++)
    {
        data = 0xf0 | cellid;
        nim_reg_write(dev, R9D_RPT_DEMAP_BETA, &data, 1);
        tabval = others_tab[cellid];
        datarray[0] = (UINT8)(tabval & 0x0ff);
        datarray[1] = (UINT8)(((tabval >> 8) & 0x0ff) | 0x10);
        nim_reg_write(dev, R11_DCC_OF_I, datarray, 2);
    }

    data = 0xe0;
    nim_reg_write(dev, R0E_ADPT_CR_CTRL, &data, 1);

#ifdef HW_ADPT_CR_MONITOR
    NIM_PRINTF("CR TAB Initialization Done \n");
#endif
   return SUCCESS;
}


/*****************************************************************************
* INT32 nim_s3501_dynamic_power(struct nim_device *dev, UINT32 *RsUbc)
* Get bit error ratio
*
* Arguments:
* Parameter1:
* Key word: power_ctrl
* Return Value: INT32
*****************************************************************************/
INT32 nim_s3501_dynamic_power(struct nim_device *dev, UINT8 snr)
{
    UINT8 coderate = 0;
    UINT32 ber = 0;

    if(dev == NULL)
    {
	   return RET_FAILURE;
	}   

    if (cnt3 >= CNT_NUM_3)
    {
        last_ber_sum = cur_ber_sum;
        cur_ber_sum = ber_sum;
        cnt3 = 0;
        ber_sum = 0;
    }
    nim_s3501_get_ber(dev, &ber);
    nim_s3501_reg_get_code_rate(dev, &coderate);
    ber_sum += ber;
    cnt3 ++;
    if (coderate < 0x04)
    {
        ber_thres = 0x120;
    }
    else
    {
        ber_thres = 0x70;
    }


    if (cur_max_iter == CUR_MAX_ITER_50)
    {
        if (ber_sum >= ber_thres)
        {
            if (snr > snr_bak)
            {
               snr_bak = snr;
            }
            cur_max_iter -= 15;
        }
    }
    else if (cur_max_iter < 50)
    {
        if (((cur_ber_sum + 0x80) < last_ber_sum) || (snr > (snr_bak + 2)))
        {
            cur_max_iter += 15;
            snr_bak = 0;
            cnt3 = 0;
            ber_sum = 0;
            last_ber_sum = 0;
            cur_ber_sum = 0;
        }
        else if (ber_sum > 3 * ber_thres)
        {
            cur_max_iter -= 15;
            if ((coderate < 0x04) && (cur_max_iter < CUR_MAX_ITER_35))
            {
                cur_max_iter = 35;
            }
            else if (cur_max_iter < 20)
            {
                cur_max_iter = 20;
            }
        }
    }

    if (cur_max_iter != last_max_iter)
    {
        NIM_PRINTF("----change cur_max_iter to %d----\n\n", cur_max_iter);
        nim_reg_write(dev, R57_LDPC_CTRL, &cur_max_iter, 1);
        last_max_iter = cur_max_iter;
    }
    return SUCCESS;
}



void nim_hw_adaptive_cr_monitor(struct nim_device *dev)
{
    UINT8 data[2]={0};
    UINT8 snr_idx = 0;
    UINT8 cr_prs = 0;
    UINT8 cr_irs = 0;
    UINT8 cr_frac = 0;

    if(dev == NULL)
    {
	   return;
	}   

    if(interval_cnt == 0)
    {
        nim_reg_read(dev, RBB_SNR_RPT1, data, 2);
        if(data[0] != old_cr_para[0] || data[1] != old_cr_para[1])
        {
            old_cr_para[0] = data[0];
            old_cr_para[1] = data[1];

            cr_frac = (old_cr_para[0] >> 2) & 0x03;
            cr_irs = (old_cr_para[0] >> 4) & 0x0f;
            if(cr_irs <= CR_IRS_VAL_6)
             {
                cr_irs += 16;
             }

            cr_prs = old_cr_para[1] & 0x07;
            if(cr_prs < CR_PRS_VAL_4)
            {
               cr_prs += 8;
            }

            snr_idx = (old_cr_para[1] >> 3) & 0x1f;

            data[0] = (snr_idx & 0x01) ? 5 : 0;
            NIM_PRINTF("--->switch to %d.%d dB Setting \n", 6 + snr_idx / 2, data[0]);

            NIM_PRINTF("OldCR:%d Wider:%d PRS:%1x IRS:%x FRAC:%d \n",
                       old_cr_para[0] & 0x01, (old_cr_para[0] >> 1) & 0x01, cr_prs, cr_irs, cr_frac);

        }

        interval_cnt = 16;
    }
    interval_cnt--;
};



INT32 nim_sw_snr_rpt(struct nim_device *dev)
{
    UINT8 data = 0;
    UINT16 var = 0;

    if(dev == NULL)
    {
	   return RET_FAILURE;
	}   

    interval_cnt++;
    if(interval_cnt == INTERVAL_CNT_10)
    {
        nim_reg_read(dev, RBC_SNR_RPT2, &data, 1);
        if (data & 0x80)
        {
            var = (data & 0x0f) << 6;
            nim_reg_read(dev, RBB_SNR_RPT1, &data, 1);
            var += (data >> 2) & 0x03f;

            if(s3501_snr_initial_en)
            {
                snr_max = var;
                snr_min = var;
                s3501_snr_initial_en = 0;
            }

            if(var > snr_max)
            {
                snr_max = var;
             }
            if(var < snr_min)
            {
               snr_min = var;
            }

            data = 0x00;
            nim_reg_write(dev, RBC_SNR_RPT2, &data, 1);

            NIM_PRINTF("*** SNR = %u min=%u max=%u\n", var, snr_min, snr_max);
        }

        interval_cnt = 0;
    }

    return SUCCESS;
}


INT32 nim_s3501_set_ssi_clk(struct nim_device *dev, UINT8 bit_rate)
{
    UINT8 data = 0;

    if(dev == NULL)
    {
	   return RET_FAILURE;
	}   
    if (bit_rate >= ssi_clock_tab[0])
    {
        // use 135M SSI debug
        nim_reg_read(dev, RDF_TS_OUT_DVBS2, &data, 1);
        data = (data & 0x0f) | 0xf0;
        nim_reg_write(dev, RDF_TS_OUT_DVBS2, &data, 1);

        nim_reg_read(dev, RCE_TS_FMT_CLK, &data, 1);
        data = (data & 0xf3) | 0x08;
        nim_reg_write(dev, RCE_TS_FMT_CLK, &data, 1);
    }
    else if (bit_rate > ssi_clock_tab[1])
    {
        // use 98M SSI debug
        data = 0x1d;
        nim_reg_write(dev, RDF_TS_OUT_DVBS2, &data, 1);
    }
    else if (bit_rate > ssi_clock_tab[2])
    {
        // use 90M SSI debug
        data = 0xfd;
        nim_reg_write(dev, RDF_TS_OUT_DVBS2, &data, 1);
        nim_reg_read(dev, RCE_TS_FMT_CLK, &data, 1);
        data = (data & 0xf3) | 0x04;
        nim_reg_write(dev, RCE_TS_FMT_CLK, &data, 1);
    }
    else if (bit_rate > ssi_clock_tab[3])
    {
        // use 83M SSI debug
        data = 0x0d;
        nim_reg_write(dev, RDF_TS_OUT_DVBS2, &data, 1);
    }
    else if (bit_rate > ssi_clock_tab[4])
    {
        // use 77M SSI debug
        data = 0x2d;
        nim_reg_write(dev, RDF_TS_OUT_DVBS2, &data, 1);
    }
    else if (bit_rate > ssi_clock_tab[5])
    {
        // use 72M SSI debug
        data = 0xfd;
        nim_reg_write(dev, RDF_TS_OUT_DVBS2, &data, 1);
        nim_reg_read(dev, RCE_TS_FMT_CLK, &data, 1);
        data = (data & 0xf3) | 0x0c;
        nim_reg_write(dev, RCE_TS_FMT_CLK, &data, 1);
    }
    else if (bit_rate > ssi_clock_tab[6])
    {
        // use 67M SSI debug
        data = 0x3d;
        nim_reg_write(dev, RDF_TS_OUT_DVBS2, &data, 1);
    }
    else
    {
        // use 60M SSI debug
        data = 0x4d;
        nim_reg_write(dev, RDF_TS_OUT_DVBS2, &data, 1);
    }
    NIM_PRINTF("clock setting is: %02x \n", data);
    return SUCCESS;
}




